# 质量门禁（Quality Gates）

目标：把“写得更好/更易读/更高质量”从主观判断变成可执行、可回归的门禁序列；同时保持栈无关（命令来自项目能力画像）。

---

## 1) 门禁分级（阻断 vs 警告）

### 阻断性门禁（失败必须停）
- 编译/构建失败（如果本次改动触及编译路径）
- 类型检查失败（项目存在 typecheck 且本次改动会影响类型）
- 核心测试失败（覆盖成功标准/核心场景的测试）
- 明确的安全红线（敏感信息泄露、明显注入/越权风险、触发 EHRB 且无法降风险）

### 警告性门禁（失败可继续但必须记录）
- 非核心 lint 规则失败
- 次要测试失败（与成功标准无关）
- 性能基准未达标但无明确指标约束（需记录并建议后续处理）

---

## 2) 推荐执行顺序（默认）

1. `fmt`（格式化）→ 降低无意义 diff 与阅读成本  
2. `lint`（静态检查）→ 早发现低级错误与坏味道  
3. `typecheck`（类型检查）→ 把潜在运行错误前置  
4. `test`（单元/集成）→ 覆盖成功标准与核心场景  
5. `security`（依赖/敏感信息/危险用法）→ 特别是外部输入与权限相关改动

命令来源：优先 `helloagents/project.md#项目能力画像`；不足时按 `references/stack-detection.md` 推断并在允许写入时固化。

---

## 2.1) 验证选择优先级（最小-最快-最高信号）

目标：用最低成本得到最高确定性证据，避免“跑一堆无关检查”导致噪声、失败堆叠与上下文膨胀。

规则（按优先级）：
1. **贴近改动面的最小验证**：优先跑能覆盖成功标准的最小测试/脚本/命令（越小越快越好）
2. **再跑门禁序列**：按 `fmt → lint → typecheck → test → security` 扩大覆盖面
3. **阻断即停**：任一阻断性门禁失败必须停止继续尝试，并按 `references/failure-protocol.md` 记录失败证据与“下一步唯一动作”
4. **证据落盘**：所有验证必须可追溯（命令 + 结果摘要），写入 `task.md##Review 记录`（或阻断时写入 `task.md##上下文快照`）

推荐最小落盘格式：
- 运行: `...` 结果: 通过/失败（关键错误 1–3 行）

---

## 2.2) 性能门禁（按需，不做无证据优化）

仅当对齐摘要的成功标准包含“性能/效率/稳定性指标”时启用：
- 建立**基线**（当前版本的指标/复现步骤）
- 明确**目标值**（例如 p95 延迟、吞吐、CPU/内存、错误率）
- 提供**可复现测量方式**（benchmark/脚本/命令/固定数据集）

未定义指标时：禁止“为了更快”做大幅重构或复杂优化；优先提升可读性与正确性，并在输出中标注“缺少性能指标”。

---

## 3) 与对齐摘要联动（强制）

规则：`why.md#对齐摘要` 中每条成功标准，必须在 `task.md` 中至少对应一个验证动作：
- 测试用例（优先）
- 可重复命令（如一次性脚本/CLI）
- 明确的手动验证步骤（兜底，必须可复现）

未建立映射时：禁止进入实现或视为验证不足（需补齐）。

---

## 4) “顺手重构”门禁（不影响目标的前提）

允许顺手重构，但必须满足：
- **行为不变量**：不改变对齐摘要所定义的对外行为/接口（除非对齐允许）
- **范围受控**：限定在相关模块/目录内；避免跨层移动造成耦合
- **验证补强**：至少跑过覆盖成功标准的测试/验证动作

重构约束细则：见 `references/refactoring-anti-coupling.md`。

---

## 5) 输出时的证据要求（完成输出必含）

在阶段完成输出的“验证结果”里必须记录：
- 运行了哪些门禁（fmt/lint/typecheck/test/security）
- 结果（通过/失败/未执行+原因）
- 若未执行，必须给出下一步可执行命令或原因（例如“项目无测试套件/命令未知需确认”）
