# 外部知识协议（External Knowledge Protocol）

目标：在需要联网搜索/MCP/文档查询时，把外部信息转成**可追溯、可验证、可失效**的工程输入，减少“随口引用→固化成事实→返工跑偏”。

适用范围：任何依赖外部资料的场景（新库/新框架、版本升级、行为差异确认、疑难排错、安全最佳实践等）。

---

## 1) 核心原则（硬规则）

1. **外部资料不是 SSOT（真值）**：它只能作为“候选证据”。结论要么被代码/测试/命令输出锚定，要么进入待确认区。
2. **引用必须带来源**：凡是“根据文档/网上说”的句子，必须附带来源指针（URL 或 MCP 资源）与获取时间。
3. **版本绑定**：必须写清适用版本/范围（例如 `v2.3+`、`React 18`、`Postgres 14`），并声明失效条件。
4. **最小摘录**：只摘录支撑结论的最小片段（1–5 行），避免长段搬运与许可风险；其余用链接。
5. **先本地后外部**：优先读取项目声明与仓库内证据（配置/CI/README/代码），外部资料仅用于补齐“本地没有的事实”。

---

## 2) 什么时候用（触发条件）

- 项目引入**从未使用过**的库/框架/工具
- 发生**重大版本升级**或行为变更（breaking changes）
- 需要确认**最佳实践**/安全建议/默认配置
- 复杂问题定位：本地线索不足、错误信息指向外部组件

---

## 3) 记录写到哪里（默认落盘）

优先写入当前方案包的 `how.md`：
- `## 外部知识与版本绑定（如使用）`（模板建议见 `templates/plan-how-template.md`）

必要时补充写入 `task.md##上下文快照`：
- 当外部资料直接影响关键决策/约束/下一步唯一动作，或会话可能中断时（见 `references/context-snapshot.md`）

团队/长期约束可沉淀到 `HAGWroks/project.md`：
- 例如固定的版本策略、合规要求、发布禁令等（但必须明确来源与适用范围）

---

## 4) 来源标注格式（推荐）

统一用 `[SRC:TOOL]` 记录外部来源（避免扩大标签集合），并结构化写清：

- Web：
  - `[SRC:TOOL] web: <url> (accessed: YYYY-MM-DD) | version: <vX.Y/unknown> | claim: <结论> | scope: <适用范围> | expires: <失效条件> | verify: <如何在本地验证>`
- MCP：
  - `[SRC:TOOL] mcp:<server> <uri> (accessed: YYYY-MM-DD) | version: <tag/sha/unknown> | claim: ... | scope: ... | expires: ... | verify: ...`

> 说明：`claim/scope/expires/verify` 允许简写，但不得省略来源与获取时间。

---

## 5) 结论分层（防止“引用变事实”）

将外部信息归入两类之一（必须二选一）：

1. **已锚定结论（可当作事实使用）**
   - 条件：能指向 `[SRC:CODE]` 或 `[SRC:TOOL]`（本地命令输出/测试结果）作为证据
   - 写法：在 how.md 写结论，并补充“本地验证证据”

2. **未锚定结论（必须当作推断/待确认）**
   - 条件：仅有外部资料，无法在当前项目中验证
   - 写法：写入 `task.md##上下文快照` 的“待确认/假设”区，标注 `[SRC:INFER]` 或 `[SRC:TODO]`，并给出验证方式/影响面

---

## 6) 最小验证策略（把外部知识变成工程证据）

优先级（从强到弱）：
1. 运行项目既有测试/门禁（`HAGWroks/project.md#项目能力画像`）
2. 创建最小可重复验证命令（一次性脚本/CLI）
3. 最小手动验证步骤（兜底，必须可复现）

原则：若无法验证，就不要把外部资料写进“事实区”。
