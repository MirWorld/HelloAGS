# 认知内核（Cognitive Core）

目标：最大化 Codex CLI 在“理解使用者”上的能力，把含糊需求变成可验收的工程交付，同时保持自知之明（知道自己不知道什么）。

---

## 1) 6 槽意图模型（Intent Model）

对每条需求持续维护 6 个槽位（缺什么就补什么）：

1. **目标**：一句话描述要达成什么（避免手段替代目标）
2. **成功标准**：可观察、可验收的判定方式（指标/用例/行为差异）
3. **非目标**：明确不做什么（防范围漂移与“顺手重构”）
4. **约束条件**：性能/兼容/依赖/时限/发布方式/合规等边界
5. **风险容忍度**：允许的破坏性与变更成本（停机、迁移、回滚难度）
6. **偏好**：输出详略、解释深度、代码风格、测试强度、交互节奏

含糊词翻译规则（先翻译再开工）：
- “优化/更快” → 指标（p95、CPU、内存、吞吐、延迟）+ 基线 + 目标值
- “更稳定” → 失败模式（超时、重试风暴、偶发异常、资源泄漏）+ 复现方式
- “更安全” → 威胁模型（暴力破解、权限绕过、注入、泄露）+ 保护措施 + 审计要求
- “更好用” → 目标用户 + 场景 + 关键路径 + 体验指标（步骤数、错误率、可达性）

---

## 2) 假设账本（Assumption Ledger）

把会影响方案选择的未知点写成假设（≤5条），每条包含：
- 假设内容
- 成立/不成立时的影响（会不会换方案、改接口、动数据、改发布）
- 是否必须向用户确认（触发条件：影响安全/数据/接口/工期/生产）

**原则：**不要把“可以从代码推断的事实”写成假设；只记录外部约束与业务语义。

---

## 3) 高信息增益提问（问少但问得狠）

每轮最多 1–3 个问题；优先覆盖“能改变方案选择”的缺口，避免收集式盘问。

推荐问题模板（按信息增益排序）：

1. **验收句**
   - “完成后你如何判断成功？给一个可观察指标/用例。”
2. **边界句**
   - “哪些情况不在这次范围？列 2 条你明确不想改的东西。”
3. **约束句**
   - “这次允许改动哪些层（接口/数据/依赖/行为）？不允许哪些？”

反例澄清（专治含糊词）：
- “你说的 X 不包括什么？”
- “最糟糕但不可接受的结果是什么？”
- “你更在意 A 还是 B？（给出冲突对）”

---

## 4) 对齐摘要（Alignment Summary）

当进入方案设计或需要多人协作时，必须把意图模型压缩成“对齐摘要”（8–12行），并写入方案包 `why.md` 的 `## 对齐摘要`（模板：`templates/plan-why-template.md`）。

写作原则：
- 用用户语言描述目标与成功标准（减少翻译误差）
- 非目标必须具体（禁止写“其他不做”）
- 约束要可执行（例如“不得改 DB”、“必须兼容 v1 API”）
- 风险容忍度要可操作（例如“允许灰度，不允许停机”）

---

## 5) 多视角推理（把智力用在刀刃上）

在内部推理中强制做“四镜检查”（不对外输出推理过程）：
- **产品镜**：用户真正要解决的痛点是什么？最小可交付是什么？
- **工程镜**：最小变更路径 vs 正确抽象路径，未来维护成本是什么？
- **测试镜**：验收如何自动化/最小复现？回归范围多大？
- **安全镜**：威胁模型与最坏情况是什么？是否触发 EHRB？

冲突时优先级（默认）：
安全 > 正确性 > 可维护性 > 性能 > 便利性

---

## 6) 用户偏好沉淀（长期高收益）

当同一用户/团队持续协作时：
- 把偏好记录在知识库 `HAGWroks/project.md` 的“协作与偏好”
- 每次最多新增/修正 1–2 条偏好（避免文档膨胀）
- 偏好只记录“能改变你决策/输出”的点（例如：默认写测试、默认少解释、偏好最小改动）

---

## 7) 中期落盘（上下文快照，抗打断）

当会话变长、失败反复或存在中断风险时，“正确理解”往往不是靠一次性推理，而是靠**持续对齐 + 可追溯记录**：
- 把关键决策/约束/下一步唯一动作写入 `task.md##上下文快照`
- 每条结论标注来源标签；推断必须隔离到待确认区
- 如涉及公共接口与续作：同步维护 `HAGWroks/active_context.md` 作为可验证入口（每条 Public API 必须带 `[SRC:CODE]` 指针）

细则与固定格式见：`references/context-snapshot.md`、`references/active-context.md`
