# 路由细则（Routing）

目标：把用户输入稳定路由到“命令/续作恢复/上下文响应/开发模式/咨询问答”，并用**阻断式规则**避免越界与重复。

---

## 0) 阻断式路由（Hard Stop）

路由是**本轮第一动作**；在路由确定前：
- 禁止读写文件
- 禁止执行命令
- 禁止输出方案/代码（除非路由结果就是“咨询问答/追问/选择/确认”）

硬规则（命中即阻断并改走对应路径；**判定顺序也是协议的一部分**）：
1. **上一轮处于等待状态**（追问/选择/确认） → 本轮只处理用户回复；不得重开流程  
   - 重要：即使用户消息包含 `~` 命令，也不得绕过等待态；若用户确实要打断改做新任务，必须走“上下文确认”（见第 7 节）。
   - 等待态回复必须先执行“Delta 先行解析”（见第 3.3 节），避免纠偏被当作无效输入吞掉。
2. **用户限制写入范围**（例如“不做/只给方案/不要改代码/不要写文件/不要落盘”）→ 先确定 `write_scope`，并按写入范围阻断越界（见第 2 节）：  
   - `no_write`：只允许咨询/追问/方案文字输出；**禁止写任何文件**
   - `helloagents_only`：允许写 `HAGSWorks/` 工作区（方案包/知识库），**禁止进入开发实施（改业务代码）**
   - `code_write`：按正常流程推进（仍受“执行入口=完整方案包/执行域护栏/质量门禁”约束）
   - 重要：`write_scope` 是上位约束，适用于所有模式（含命令模式）。命令只决定“走哪条流程”，不允许绕过写入范围。
3. **运行时异常信号未闭环**（模型切换/输出不完整/降级提示）→ 先落盘证据与恢复检查点，再继续  
   - 触发信号（启发式，避免绑定具体措辞；命中任一即可）：  
     - 看到 `model/rerouted`（或 “routed … fallback/降级/以不同模型继续” 类系统提示）  
     - 看到 `response.incomplete` / “输出不完整/被截断” 类提示  
   - 处理原则：把信号当作 `[SRC:TOOL]`，并结构化落到 `task.md##上下文快照`：  
     - `- [SRC:TOOL] model_event: model_rerouted` 或 `response_incomplete`（结构契约见 `references/contracts.md`）  
     - 在其后追加**恢复检查点**（至少包含 `repo_state:` 与 `下一步唯一动作:`；细则见 `references/context-snapshot.md`）  
   - 路由：优先改走 `references/resume-protocol.md` 的断层恢复（禁止依赖聊天记忆继续推进）；若 `write_scope = no_write` 则只做只读恢复与对话内说明（不得落盘）。
4. **包含 `~` 命令** → 进入命令模式；但仍必须遵守 `write_scope`，如冲突则阻断并请求裁决（见第 2.3 节）
5. **目标路由为开发实施/执行，但缺少可执行方案包** → 输出错误并路由回 `~plan`/方案设计
6. **EHRB 风险信号未确认** → 必须先停下做风险确认，再决定是否继续（见 `references/safety.md`）

需要阻断交互时：优先使用 `templates/output-format.md` 的 `❓/⚠️/❌` 交互模板，给 2–3 个可选决策。

---

## 1) 路由优先级（互斥决策树）

命中即停止：
0. **等待状态回复**：上一轮 `status: awaiting_user_input` → 本轮只处理该等待问题（含 Delta 先行解析；见第 3.3 节）
1. **命令模式**：`~auto/~plan/~exec/~init`
2. **续作/断层恢复**：用户要求“继续/接着/上次…”，但当前不处于追问/选择/确认状态 → 按 `references/resume-protocol.md` 恢复
3. **上下文响应**：追问/选择/确认/反馈（延续上一阶段）
4. **开发模式**：微调 → 轻量迭代 → 标准开发 → 完整研发（兜底）
5. **咨询问答**：解释/讨论/不写文件
   - 若任务为“提示词/规则优化”：按 `references/prompt-optimization.md` 的诊断清单与三档交付输出；默认 `write_scope = no_write`

---

## 2) 关键判定维度

- **意图类型**：问答型 | 改动型 | 命令型
- **写入范围（write_scope）**：`no_write` | `helloagents_only` | `code_write`
- **改动范围**：无 | 微（≤2文件≤30行）| 小（3–5文件）| 中（多文件）| 大（架构级）| 不确定
- **需求明确度**：明确 | 模糊 | 需澄清（尤其缺成功标准/边界/约束）
- **上下文状态**：无 | 追问中 | 选择中 | 确认中
- **上下文状态（补充）**：续作/断层（上下文不足以继续，需要恢复）
- **风险信号（EHRB）**：有 | 无（细则见 `references/safety.md`）

### 2.1 写入范围（write_scope）定义（无歧义）

- `no_write`：**不写任何文件**（只在对话里给解释/方案/清单）；不创建方案包、不更新知识库
- `helloagents_only`：只允许写入 `${PROJECT_ROOT}/HAGSWorks/` 工作区（plan/wiki/history/project/active_context 等），**禁止修改业务代码/配置**
- `code_write`：允许修改业务代码/配置；仍必须遵守“执行入口=完整方案包”与执行域/质量门禁护栏

### 2.2 写入范围判定（保守优先）

语义判定（不是关键词匹配），按“更保守”优先：

- 用户说“不要写文件/不要落盘/只在聊天里给/不要生成任何文件” → `no_write`
- 用户说“只审/只看/只分析/只讨论/只给结论/先看看再说（不改不落盘）” → `no_write`
- 用户说“只给方案/不要做实现/不要改代码/只写方案包（不改业务代码）” → `helloagents_only`
- 用户说“去做/按你的去做/修复/实现/改代码/落地” → `code_write`

歧义处理（必须阻断澄清）：
- 用户只说“不要改文件”但未说明是否允许写 `HAGSWorks/` 工作区 → 默认按 `no_write` 处理，并给 2 个选项让用户确认：
  - `[1] 只在对话里给方案（不写任何文件）`
  - `[2] 允许写 HAGSWorks/ 工作区（只写方案包/知识库，不改业务代码）`

### 2.3 命令与写入范围冲突裁决（必须）

命令决定流程形态；`write_scope` 决定允许写入的最大边界。两者冲突时，必须阻断并让用户裁决（禁止擅自越界）。

最低写入范围要求（用于判定冲突）：

| 命令 | 最低 write_scope | 说明 |
|---|---|---|
| `~init` / `~wiki` | `helloagents_only` | 会创建/补齐 `${PROJECT_ROOT}/HAGSWorks/` |
| `~plan` | `no_write`（可） / `helloagents_only`（落盘方案包） | 不落盘时可纯对话出方案；要写方案包必须允许写 `HAGSWorks/` |
| `~exec` | `code_write` | 会改业务代码/跑门禁/写入执行记录 |
| `~auto` | `code_write` | 全链路（方案+执行） |

冲突处理模板（示例：用户 `no_write` + `~init`）：

```
❓【HelloAGENTS】- 写入范围冲突

检测到写入范围与命令冲突：
- write_scope: no_write（不写任何文件）
- 命令: ~init（需要创建/补齐 HAGSWorks/）

[1] 保持 no_write - 不执行 ~init，仅在对话中说明 ~init 会做什么
[2] 允许写 HAGSWorks/ - 将 write_scope 提升为 helloagents_only 后执行 ~init
[3] 取消 - 终止本次命令

────
🔄 下一步: 请输入序号选择
回复契约: 只回复 `1` / `2` / `3`

<helloagents_state>
version: 1
mode: init
phase: routing
status: awaiting_user_input
awaiting_kind: choice
package:
next_unique_action: "等待用户输入序号 1-3"
</helloagents_state>
```

---

## 3) 上下文状态判定

优先级：**先读状态标记块，再用启发式兜底**（避免因文案/模板变化导致误判）。

### 3.1 结构化判定（优先，强推荐）

如果上一轮输出末尾包含 `templates/output-format.md` 定义的 `&lt;helloagents_state&gt;...&lt;/helloagents_state&gt;`：
- 当 `status: awaiting_user_input`：
  - `awaiting_kind: questions` → 追问中
  - `awaiting_kind: choice` → 选择中
  - `awaiting_kind: confirm` → 确认中

本轮规则（命中即阻断）：
- 只处理用户对该等待状态的回复（不得重开流程）
- 等待态回复必须先执行“Delta 先行解析”（见第 3.3 节），避免纠偏被当作无效输入吞掉
- 若用户回复与 `awaiting_kind` 不匹配：
  - 若本轮输入包含 Delta（纠偏/新增约束）：**不算无效输入**；应先落盘 Delta，再保持等待态并重发原问题
  - 若本轮输入不包含 Delta：按 `templates/output-format.md` 的“无效输入再次询问”重试，并更新标记块

### 3.2 启发式判定（兜底）

- **追问中**：上一条为 `❓【HelloAGENTS】- 需求分析` 且评分<7分
- **选择中**：上一条为 `❓【HelloAGENTS】- 方案构思` 或 `❓【HelloAGENTS】- 开发实施（多方案包）`
- **确认中**：上一条为 `✅【HelloAGENTS】- <阶段>` 且“下一步”要求确认
- **续作/断层**：用户表达“继续/接着/上次…”，但无法匹配上述三种状态，或当前上下文不足以确定下一步

当上一轮缺失 `<helloagents_state>` 但明显在等待用户回复时，按以下信号兜底（由强到弱）：
- **确认中（兜底）**：上一条包含 `等待确认:` 或包含 `回复契约: 只回复 `确认` 或 `取消``
- **选择中（兜底）**：上一条包含 `[1]`/`[2]` 选项列表，且包含 `请输入` 或包含 `回复契约: 只回复 `1``
- **追问中（兜底）**：上一条包含编号问题列表，且包含 `请按序号回答` 或包含 `回复契约: 按序号逐条回答`

兜底仍无法判定（例如用户只回了 `1`，但无法确定在回答哪个等待问题）：
- 必须输出“上下文确认”交互，要求用户选择“回答上一轮等待问题 / 开始新任务”，避免擅自重开流程或猜测分支

处理规则：
- 追问中：用户补充 → 重新评分 → 继续/再追问
- 选择中：用户给序号 → 继续选中项
- 确认中：用户确认 → 进入下一阶段；拒绝 → 输出取消格式
- 续作/断层：按 `references/resume-protocol.md` 走固定恢复顺序（必要时询问用户选择方案包）

### 3.3 等待态输入解析（Delta 先行解析，必须）

目的：让“中途纠偏/新增约束（Enter/Tab 注入）”在等待态也能被捕获并可追溯，避免被 `awaiting_kind` 校验吞掉。

规则（按顺序执行）：
1) **先提取 Delta**（纠偏块）：
   - **优先识别显式前缀**（推荐，最稳）：`新增约束:` / `纠偏:` / `非目标:` / `允许:` / `禁止:`
   - **保守兜底（无感增强）**：当用户输入已满足“回复契约”，且在同一条消息里额外追加了“强约束句”，即使没写前缀也按 Delta 处理并落盘（避免压缩后丢约束）。  
     - 强约束句（示例，不要求完全匹配）：以 `不要/禁止/必须/只允许/别/不许` 开头，或包含“不要改/不要新增/禁止改/必须保留”等明确边界语义  
     - 推荐写法仍是：**第一行只写合法回复**（如 `1`/`确认`），第二行起写约束；但允许同一行追加（例如 `1，不要改 DB`）
   - Delta 可单独一条消息发送，也可与合法回复合并发送；系统会先处理 Delta 再处理回复（只要回复契约满足）。
2) **若命中 Delta**：
   - 若允许写入且已存在方案包：按第 6.1 节的“可追溯落盘”四步执行（写快照 + 更新执行域 + 更新下一步唯一动作）。
   - 若不允许写入（`write_scope=no_write`）或尚无方案包：在本轮输出中明确“已采纳该约束”，并将其作为本轮后续判断的上位约束；如后续允许写入/创建方案包，应在第一时间回填到 `task.md##上下文快照`。
3) **再解析等待态回复**（从用户输入中剥离 Delta 后的剩余内容）：
   - 如果剩余内容满足 `awaiting_kind` 的回复契约 → 正常推进
   - 如果不满足，但本轮包含 Delta → 保持等待态并重发原问题（不走“无效输入”）
   - 如果既不满足且也不包含 Delta → 走“无效输入再次询问”

---

## 4) 开发模式选择（非命令）

> 重要：本 Skill **不再支持**“只生成 `task.md` 的简化方案包”。任何进入执行（改代码/跑验证/产生变更）的路径，都必须先创建**完整方案包**（`why.md` + `how.md` + `task.md`）。

### 4.1 微调（Quick Fix）
条件（全部满足）：
- 改动型且指令明确（含文件路径/明确位置）
- ≤2文件且≤30行
- 无架构影响、无 EHRB

动作：
- 按 `references/quickfix-protocol.md` 执行 Quick Fix 快路径（优先使用 quickfix 模板创建最小完整方案包）
- 在 `task.md##上下文快照` 写一次检查点（Workset + 下一步唯一动作）后再开始改动
- 按任务执行改动、验证、迁移到 history（执行细则：`develop/SKILL.md`）
- 知识库缺失处理：
  - 若 `write_scope != no_write` 且需要落盘（写 `HAGSWorks/`）：先**隐式执行一次 `~init`**（幂等补齐）再继续
  - 若 `write_scope = no_write`：只提示 `~init` 会做什么（不创建）

### 4.2 轻量迭代（Light Iteration）
条件（全部满足）：
- 改动型且指令明确
- 3–5 文件
- 无架构决策、无 EHRB

动作：
- 创建**最小完整方案包**（`why.md` + `how.md` + `task.md`，内容允许极简；若本质是“改参数/改配置值”，可参考 `references/quickfix-protocol.md` 的微清单）
- 执行改动、更新知识库、迁移到 history、扫描遗留方案（执行细则：`develop/SKILL.md`）

### 4.3 标准开发
适用：
- 需求明确但影响多文件/多模块（>5文件），且不涉及架构级决策

动作：
- 方案设计 → 开发实施（可跳过需求分析评分）

### 4.4 完整研发（默认兜底）
满足任一即进入：
- 需求模糊（尤其缺成功标准/边界/约束）
- 涉及架构决策/新模块/技术选型/影响范围不确定
- 存在 EHRB 信号

动作：
- 需求分析 → 方案设计 → 开发实施

---

## 5) 命令模式（高优先级，等待态之后）

- `~init/~wiki`：知识库初始化/重建（按 `kb/SKILL.md`）
- `~plan/~design`：需求分析（必要时；若需求明确且为 Quick Fix/轻量迭代，可通过 `design/SKILL.md` 的“方案设计入场门槛”跳过评分）→ 方案设计（生成方案包）
- `~exec/~run/~execute`：开发实施（执行已有方案包）
- `~auto/~helloauto/~fa`：全链路（需求分析→方案设计→开发实施）

命令确认/输出格式：遵循 `templates/output-format.md`（G6.1–G6.4）。

补充（无感，推荐默认）：当命令/流程需要写入 `HAGSWorks/`，但 `HAGSWorks/` 缺失时：
- 若 `write_scope != no_write`：先隐式执行一次 `~init`（幂等补齐）再继续
- 若 `write_scope = no_write`：按第 2.3 节“命令与写入范围冲突裁决”阻断并让用户裁决

---

## 6) Feedback-Delta（需求变更）

语义判定（不是关键词匹配）：
- **重大变更（重回需求分析）**：新增/删除模块、核心 API 改动、技术栈更换、推翻原方案核心设计
- **局部增量（留在原阶段）**：针对当前产物的小改动、补充验收标准、补充边界/约束

### 6.1 执行中纠偏 / 引导注入（Enter / Tab）

执行过程中用户追加一句“新约束/非目标/范围收口”（无论是立即发送还是排队注入）都视为 Feedback-Delta，必须做一次**可追溯落盘**（避免只存在于聊天上下文）：

1) 把用户原话写入 `task.md##上下文快照` 的“用户原话”区：`[SRC:USER] "……"`（保持原句，避免改写漂移）  
2) 判定 Delta 类型：`局部增量` / `重大变更`，并把“决策 + 理由”写入快照“决策”区  
3) **强制更新执行域声明**（Allow/Deny/NewFiles/Refactor）：把更新后的结论写入快照“决策”区（细则见 `references/execution-guard.md`）  
4) **强制更新“下一步唯一动作”**：用 1 条可执行动作收口（继续实现/切换路径/先补验证/等待确认），写入快照“下一步唯一动作”区（细则见 `references/context-snapshot.md`）

---

## 7) 上下文打断（新需求插入）

当检测到新输入可能打断当前任务且边界不清时，使用“上下文确认”交互格式：

```
❓【HelloAGENTS】- 上下文确认

检测到新输入，当前任务尚未完成。
[1] 继续当前任务 - [当前任务简述]
[2] 开始新任务 - [新任务简述]

────
🔄 下一步: 请输入序号选择
回复契约: 只回复 `1` 或 `2`

<helloagents_state>
version: 1
mode: auto
phase: routing
status: awaiting_user_input
awaiting_kind: choice
package:
next_unique_action: "等待用户输入序号 1-2"
</helloagents_state>
```

