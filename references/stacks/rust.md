# Rust Playbook（推荐默认 + 少量硬禁止）

目标：当项目被判定为 Rust（`Cargo.toml`）时，提供一套**默认可维护**、**可闭环验证**的实现习惯。  
原则：项目既有约定/CI/脚本优先；本 Playbook 仅作为兜底与收敛默认值。

---

## 硬禁止（高风险，默认不允许）

1. **生产代码禁用 `unwrap()` / `expect()`**  
   - 例外：测试代码、明确“不可能失败”的初始化（仍建议加上下文或注释说明不变量）。
2. **禁用无注释的 `unsafe`**  
   - 必须隔离在最小范围，并写明不变量（为什么安全、哪些前置条件必须成立）。
3. **异步上下文禁用阻塞调用**  
   - 禁止在 async 路径里直接做明显阻塞（同步 IO/长计算/`std::thread::sleep` 等）；需要则使用 runtime 的 `spawn_blocking` 或拆到同步边界。

---

## 推荐默认（更灵活；可被项目现状覆盖）

### 错误处理
- **应用/CLI**：默认使用 `anyhow`（便于快速加上下文）  
- **库/可复用模块**：默认使用 `thiserror`（稳定错误枚举/对外契约更清晰）
- 对外边界（API/CLI/Job）统一落点做错误映射与日志记录，避免到处 `map_err` 胶水。

### 日志与可观测性
- 若项目已使用 `tracing`：延续 `tracing`；否则不要随意引新体系（避免 `log`/`tracing` 混用）。

### 模块与可见性
- 默认最小可见性：先 `mod` 私有，确有需要再 `pub`。  
- 公共 API 变化视作“契约变化”：要有对应验证动作（测试/最小命令）并更新派生文档（如启用 Active Context）。

### 依赖与 features
- 新增依赖前先复用（标准库/已有 crate）。新增时写明目的与替代方案（一句话即可）。
- features：只在确实需要可选能力时引入；避免默认启用过多 feature 导致编译慢/依赖膨胀。

---

## 闭环（最小验证动作）

优先使用项目声明的命令矩阵；缺失时按以下兜底闭环：

- **快路径（最快信号）**：`cargo test`
- **标准路径（更强信号）**：`cargo fmt --check` → `cargo clippy -- -D warnings` → `cargo test`

